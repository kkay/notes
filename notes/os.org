\<2013-07-22 周一>



* windows(x86)

** 线程同步

*** 用户模式

**** TODO Interlocked

**** TODO 临界区

win-vista

**** TODO slim读写锁

PSRWLOCK
InitializeSRWLock()
write:
AcquireSRWLockExclusive()
ReleaseSRWLockExclusive()

read:
AcquireSRWLockShared()
ReleaseSRWLockShared()

+ 不存在删除SRWLOCK的函数，
+ 不能递归获得SRWLOCK
+ 如果锁已被占用，调用AcquireSRWLock线程将被阻塞

 
**** 条件变量

*** 内核模式

线程（进程）内核对象在创建的时候总是处于未触发(unsignaled)状态，当线程终止的时候，操作系统会自动将线程对象的状态改为已触发（signaled），线程内核对象绝对不可能回到未触发状态。


等待成功所引起的副作用：函数返回之前，它会使自动重置事件对象变为非触发
状态。

进程和线程内核对象完全没有副作用。


**** 可等待的计时器内核对象
可等待的计时器是这样一种内核对象，它会在某个指定的时间触发，或每隔一段
时间触发一次。

CreateWaitableTimer

当手动重置计时器被触发的时候，正在等待该计时器的所有线程都会变成可调度
状态，当自动重置计时器被触发的时候，只有一个正在等待该计时器的线程会变
成可调度状态。

APC


用户计时器需要在应用程序中使用大量的用户界面基础设施，从而消耗更多的资
源。此外可等待计时器是内核对象，它们不仅可以在多个线程间共享，而且可以
具备安全性。用户计时器产生WM_TIMER消息，这个消息被送回调用SetTimer的线
程（对回调计时器来说），或者被送回创建窗口的线程（对基于窗口的计时器来
说）。因此当一个用户计时器触发的时候，只有一个线程会得到通知。另一方面，
多个线程可以等待可等待计时器，如果计时器是手动重置计时器，那么有多个线
程可以变成可调度状态。


**** 信号量


信号量内核对象用来对资源进行计数。
规则：
+ 当前资源计数大于0，那么信号量处于触发状态
+ 当前资源计数等于0，信号量处于未触发状态

CreateSemaphore()
ReleaseSemaphore()

**** 互斥量

互斥量与其他内核对象不同，它们具有“线程所有权”的概念。如果占用互斥量
的线程在释放互斥量之前终止，系统认为互斥量被遗弃


**** 异步设备I/O























     



** 内存

*** 进程的虚拟空间地址
每个进程都有自己的虚拟地址空间。对32位进程来说，这个地址空间的大小为4GB。
虚拟空间被划分成许多分区（partition）

**** 空指针赋值分区
从0x00000000到0x0000FFFF的闭区间，保留该分区的目的是为了帮助程序员捕获对空指针的赋值。

**** 用户模式分区

这一分区是进程地址空间的驻地。
x86（普通） 0x00010000-0x7FFEFFFF，大小2GB
进程无法通过指针来读取、写入或以任何方式，访问驻留在这一分区中其他进程的数据。

**** 内核模式分区

这一分区是操作系统代码的驻地。与线程调度、内存管理、文件系统支持、网络支持以及设备驱动程序相关的代码都载入到该分区。驻留在这一分区内的任何东西为所有进程共有。

*** 地址空间中的区域
当系统创建一个进程并赋予它地址空间时，可用地址空间中的大部分是闲置的或尚未分配的。为了使用这部分地址空间，我们必须调用VirtualAlloc来分配其中的区域(region)。分配区域的操作被称为预定（reserving）
系统确保区域的起始地址正好是分配粒度的整数倍（64K）。
当应用程序预定地址空间中的一块区域时，系统会确保区域的大小正好是系统页面大小的整数倍。页面是一个内存单元，系统通过它来管理内存。x86系统使用的页面大小为4KB。

*** 给区域调拨物理存储器
为了使用所预定的地址空间区域，我们还必须分配物理存储器，并将存储器映射到所预定的区域。这个过程被称为调拨（committing）物理存储器。物理存储器始终都以页面为单位来调拨。通过VirtualAlloc。

*** 物理存储器和页交换文件
当今的操作系统能让磁盘空间看起来像内存一样，磁盘上的文件一般被称为页交换文件（paging file）


*** 虚拟内存

最适合用来管理大型对象数组或大型结构数组

每个进程的地址空间中最开始的64KB始终是闲置的

*** 线程栈

*** 内存映射文件
内存映射文件主要用于以下三种情况：
+ 系统使用内存映射文件来载入并运行exe文件和动态链接库。这大量节省了页交换文件的空间以及应用程序启动的时间
+ 利用内存映射文件来访问磁盘上的数据文件。这使得我们可以避免直接对文件进行I/O操作和对文件内容进行缓存。
+ 同一台机器的不同进程之间共享数据。




*** 堆

堆非常适合分配大量的小型数据，与虚拟内存和内存映射文件相比，堆是用来管理链表和树的最佳方式。

在进程中创建额外堆的原因：

+ 对组件进行保护
+ 更有效的内存管理
+ 局部访问
+ 避免线程同步的开销
+ 快速释放


** 动态链接库
*** 导出 __declspec(dllexport)









* Unix

** POSIX线程

单个线程可以通过下列三种方式退出：
+ 线程从启动例程中返回
+ 线程被同一进程中的其他线程取消
+ 线程调用pthread_exit

如果线程是通过从它的启动例程中返回而终止的话，那么它的清理处理程序就不会被调用，还要注意清理处理程序是按照与它们安装时相反的顺序被调用的。

*** POSIX线程同步

**** 互斥锁（mutex）
pthread_mutex_t
pthread_mutex_init()
pthread_mutex_destory()

pthread_mutex_lock()
pthread_mutex_unlock()
pthread_mutex_trylock(),锁在被占据时返回EBUSY而不是挂起等待。

POSIX线程锁机制的Linux实现都不是取消点，因此，延迟取消类型的线程不会因收到取消信号而离开加锁等待。
值得注意的是，如果线程在加锁后解锁前被取消，锁将永远保持锁定状态，因此
如果在关键区段内有取消点存在，或者设置了异步取消类型，则必须在退出回调
函数中解锁。这个锁机制同时也不是异步信号安全的，也就是说，不应该在信号
处理过程中使用互斥锁，否则容易造成死锁。


**** 读写锁

pthread_rwlock_init()
pthread_rwlock_destroy()



**** 条件变量

pthread_cond_t
pthread_cond_init()
pthread_cond_destroy()

pthread_cond_wait()
pthread_cond_timewait()


*** POSIX线程属性

**** 线程栈属性
对进程来说，虚拟地址空间的大小是固定的，进程中只有一个栈，所以它的大小通常不是问题。但对线程来说，同样大小的虚拟地址空间必须被所有的线程栈共享。如果应用程序使用了太多的线程，致使线程栈的累计大小超过了可用的虚拟地址空间，这时就需要减少线程默认的栈大小。另一方面，如果线程调用的函数分配了大量的自动变量或者调用的函数涉及很深的栈帧（stack frame），那么这时需要的栈大小可能要比默认的大。
pthread_attr_setstack
pthread_attr_getstack

pthread_attr_init
pthread_attr_destroy

**** 线程私有数据
线程私有数据（也称线程特定数据）是存储和查询与某个线程相关的数据的一种机制。

** 进程

ID为0的进程通常是调度进程，常常被称为交换进程（swapper）。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。

fork(): 返回两次，父进程返回子进程的id，子进程返回0。子进程是父进程的副本，子进程获得父进程数据空间、堆和栈的副本。父、子进程并不共享这些存储空间部分，父子进程共享正文段。

fork有下面两种用法：
+ 一个父进程希望复制自己，使父、子进程同时执行不同的代码段。
+ 一个进程要执行一个不同的程序，这对shell是常见的情况。

vfork用于创建一个新进程，而该新进程的目的是exec一个新程序。vfork与fork一样都创建一个子进程，但它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec（或exit），于是也就不会存访该地址空间，相反，在子进程调用exec之前，它在父进程的空间中运行。

vfork和fork之间的另一个区别是：vfork保证子进程先运行，在它调用exec后父进程才可能被调度。

*** exit函数

进程有五种正常终止方式：

+ main函数内执行return语句。这等效于调用exit。
+ 调用exit函数，其操作包括调用各终止处理程序，然后关闭所有标准I/O流等。
+ 调用_exit或_Exit函数。
+ 进程的最后一个线程在其启动例程中执行返回语句。
+ 进程的最后一个线程调用pthread_exit函数。

三种异常终止方式如下：
+ 调用abort。它产生SIGABRT信号。
+ 当进程接收到某些信号时。
+ 最后一个线程对“取消”请求作出响应。

不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等。

对于父进程已经终止的所有进程，它们的父进程都改变为init进程。

*** wait和waitpid函数

当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。
区别：
+ 在一个子进程终止前，wait使其调用者阻塞，而waitpid有一个选项，可使调用者不阻塞。
+ waitpid并不等待在其调用之后的第一个终止子进程，它有若干个选项，可以控制它所等待的进程。


*** exec函数

*** 信号
产生信号的条件：
+ 用户按某些终端键时，引发终端产生的信号。
+ 硬件异常产生信号。
+ 进程调用kill(2)函数可将信号发送给另一个进程或者进程组。
+ 用户可用kill(1)命令将信号发送给其他进程。
+ 当检测到某种软件条件已经发生。并应将其通知有关进程时也产生信号。


**** signal函数


** 守护进程

*** IPC

**** 管道



*** 

  
