<2013-07-22 周一>



* windows

** 线程同步

*** 用户模式

**** TODO Interlocked

**** TODO 临界区

win-vista

**** TODO slim读写锁

PSRWLOCK
InitializeSRWLock()
write:
AcquireSRWLockExclusive()
ReleaseSRWLockExclusive()

read:
AcquireSRWLockShared()
ReleaseSRWLockShared()

+ 不存在删除SRWLOCK的函数，
+ 不能递归获得SRWLOCK
+ 如果锁已被占用，调用AcquireSRWLock线程将被阻塞

 
**** 条件变量

*** 内核模式

线程（进程）内核对象在创建的时候总是处于未触发(unsignaled)状态，当线程终止的时候，操作系统会自动将线程对象的状态改为已触发（signaled），线程内核对象绝对不可能回到未触发状态。


等待成功所引起的副作用：函数返回之前，它会使自动重置事件对象变为非触发
状态。

进程和线程内核对象完全没有副作用。


**** 可等待的计时器内核对象
可等待的计时器是这样一种内核对象，它会在某个指定的时间触发，或每隔一段
时间触发一次。

CreateWaitableTimer

当手动重置计时器被触发的时候，正在等待该计时器的所有线程都会变成可调度
状态，当自动重置计时器被触发的时候，只有一个正在等待该计时器的线程会变
成可调度状态。

APC


用户计时器需要在应用程序中使用大量的用户界面基础设施，从而消耗更多的资
源。此外可等待计时器是内核对象，它们不仅可以在多个线程间共享，而且可以
具备安全性。用户计时器产生WM_TIMER消息，这个消息被送回调用SetTimer的线
程（对回调计时器来说），或者被送回创建窗口的线程（对基于窗口的计时器来
说）。因此当一个用户计时器触发的时候，只有一个线程会得到通知。另一方面，
多个线程可以等待可等待计时器，如果计时器是手动重置计时器，那么有多个线
程可以变成可调度状态。


**** 信号量


信号量内核对象用来对资源进行计数。
规则：
+ 当前资源计数大于0，那么信号量处于触发状态
+ 当前资源计数等于0，信号量处于未触发状态

CreateSemaphore()
ReleaseSemaphore()

**** 互斥量

互斥量与其他内核对象不同，它们具有“线程所有权”的概念。如果占用互斥量
的线程在释放互斥量之前终止，系统认为互斥量被遗弃


**** 异步设备I/O























     

* Unix

** POSIX线程同步

*** 互斥锁（mutex）
pthread_mutex_t
pthread_mutex_init()
pthread_mutex_destory()

pthread_mutex_lock()
pthread_mutex_unlock()
pthread_mutex_trylock(),锁在被占据时返回EBUSY而不是挂起等待。

POSIX线程锁机制的Linux实现都不是取消点，因此，延迟取消类型的线程不会因收到取消信号而离开加锁等待。
值得注意的是，如果线程在加锁后解锁前被取消，锁将永远保持锁定状态，因此
如果在关键区段内有取消点存在，或者设置了异步取消类型，则必须在退出回调
函数中解锁。这个锁机制同时也不是异步信号安全的，也就是说，不应该在信号
处理过程中使用互斥锁，否则容易造成死锁。

*** 条件变量

pthread_cond_t
pthread_cond_init()
pthread_cond_destroy()

pthread_cond_wait()
pthread_cond_timewait()
    
